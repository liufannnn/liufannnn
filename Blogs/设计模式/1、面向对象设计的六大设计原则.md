# 一、前言

| 缩写 | 英文名称 | 中文名称 |
| :- | :- | :- |
| SRP | Single Responsibility Principle | 单一职责原则 |
| OCP | Open Close Principle | 开闭原则 |
| LSP | Liskov Substitution Principle | 里氏替换原则 |
| LoD | Law of Demeter （ Least Knowledge Principle） | 迪米特法则（最少知道原则） |
| ISP | Interface Segregation Principle | 接口分离原则 |
| DIP | Dependency Inversion Principle | 依赖倒置原则 |

上表列出了面向对象设计的六大设计原则名称以及缩写。注意，<u>通常所说的 SOLID（上方表格缩写的首字母，从上到下）设计原则没有包含本篇介绍的迪米特法则，而只有其他五项</u>。另外，本篇不包含合成/聚合复用原则（CARP），因为笔者认为该原则没有其他六个原则典型，而且在实践中也不容易违背，有兴趣的同学可以自行查资料学习。

在以下章节，笔者将会按照难易程序排列，分别讲解阐述这些设计原则。并且会首先描述一个应用场景（需求点），然后利用 Swift 代码和 UML 类图结合方便理解。

> 注意：
>
> Java 里的接口在 Swift 和 Objective-C 里面叫做协议。虽然 Demo 是用 Swift 写的，但是因为协议的叫法比较小众，故后面一律用接口代替协议这个说法。

# 二、面向对象设计的六大设计原则

## 1、开闭原则（Open Close Principle）

### 1.1、定义

    Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
    
    一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

### 1.2、需求实践

设计一个在线课程类：由于教学资源有限，开始的时候只有文字讲解的课程。 但是随着教学资源的增多，后来增加了视频课程，音频课程以及直播课程。

#### 1.2.1、不好的设计

```swift
class Course {
    var teacherName: String        // 讲师名称
    var courseName: String         // 课程名称
    var courseIntroduction: String // 课程介绍
    var courseContent: String      // 文字课程
}

// Course 类声明了最初的在线课程所需要的数据
//
// 接着按照上面所说的需求变更：增加了视频，音频，直播课程

class Course {
    var teacherName: String        // 讲师名称
    var courseName: String         // 课程名称
    var courseIntroduction: String // 课程介绍
    var courseContent: String      // 文字课程

    var videoURL: String           // 视频课程
    var audioURL: String           // 音频课程
    var liveURL: String            // 直播课程
}
```

很显然，这个设计不是一个好的设计：
1. 随着需求的增加，需要反复修改之前创建的 `Course` 类
2. 给新增的类造成了不必要的冗余

之所以会造成上述两个缺陷，是因为该设计没有遵循对修改关闭，对扩展开放的开闭原则，而是反其道而行之：开放修改，而且不给扩展提供便利。

#### 1.2.2、较好的设计

```swift
class Course {
    var teacherName: String        // 讲师名称
    var courseName: String         // 课程名称
    var courseIntroduction: String // 课程介绍
}

class TextCourse: Course {
    var content: String            // 文字课程
}

class VideoCourse: Course {
    var url: String                // 视频课程
}

class AudioCourse: Course {
    var url: String                // 音频课程
}

class LiveCourse: Course {
    var url: String                // 直播课程
}
```

这样一来，上面的两个问题都得到了解决
1. 随着课程类型不断增加，`Course` 类不用做任何修改
2. 新增的课程继承自 `Course` 类，独有数据分属于不同的子类，数据没有任何冗余

### 1.3、UML 类图对比

![](https://github.com/liufannnn/liufannnn/blob/main/BlogImages/开闭原则UML类图.png?raw=true)

### 1.4、回读定义

    Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.
    
    一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

在需求设计之初，就要想清楚在该场景里哪些数据是一定不变的，哪些是很容易变动的。将后者抽象成<sup>[接口](#myfootnote1)</sup>或方法。

## 2、单一职责原则（Single Responsibility Principle）

### 2.1、定义

    A class should have a single responsibility, where a responsibility is nothing but a reason to change.
    
    一个类只允许有一个职责，即只有一个导致该类变更的原因。

### 2.2、需求实践

初始需求：需要创造一个员工类，这个类有员工的一些基本信息。

新需求：增加两个方法：
1. 判定员工在今年是否升职
2. 计算员工的薪水

#### 2.2.1、不好的设计

```swift
class Employee {
    var name: String       // 员工名称
    var address: String    // 居住地址
    var employeeID: String // 员工编号

    // ⬇️⬇️⬇️ 新需求 ⬇️⬇️⬇️

    func calculateSalary() -> Double {
        // 计算薪水
    }

    func willGetPromotionThisYear() -> Bool {
        // 今年是否晋升
    }
}
```

表面上看，这样设计并没有什么问题，因为都是和员工有关的。

但却违反了单一职责原则：薪水计算是财务部门的职责；是否升职是人事部门的职责。

假设晋升的机制变了，或税收政策变化影响到工资发放，我们还得回过头来修改这个类。

#### 2.2.2、较好的设计

```swift
class Employee {
    var name: String       // 员工名称
    var address: String    // 居住地址
    var employeeID: String // 员工编号
}

class FinancialApartment {
    func calculateSalary(employee: Employee) -> Double {
        // 计算 employee 薪水
    }
}

class HRApartment {
    func willGetPromotionThisYear(employee: Employee) -> Bool {
        // 今年 employee 是否晋升
    }
}
```

这样一来，无论以后晋升机制、税收政策如何变化，我们只需要去修改对应的部门类即可

### 2.3、UML 类图对比

![](https://github.com/liufannnn/liufannnn/blob/main/BlogImages/单一职责原则UML类图.png?raw=true)

### 2.4、回读定义

    A class should have a single responsibility, where a responsibility is nothing but a reason to change.
    
    一个类只允许有一个职责，即只有一个导致该类变更的原因。

往往在软件开发中随着需求的不断增加，可能会给原来的类添加一些本来不属于它的一些职责，从而违反了单一职责原则。如果我们发现当前类的职责不仅仅有一个，就应该将本来不属于该类真正的职责分离出去。

## 3、依赖倒置原则（Dependency Inversion Principle）

### 3.1、定义

    1. Depend upon Abstractions. Do not depend upon concretions.
    2. Abstractions should not depend upon details. Details should depend upon abstractions.
    3. High-level modules should not depend on low-level modules. Both should depend on abstractions.
    
    1、依赖抽象，而不是依赖实现；
    2、抽象不应该依赖细节，细节应该依赖抽象；
    3、高层模块不能依赖低层模块，二者都应该依赖抽象。

### 3.2、需求实践

需求：用代码模拟一个实际项目开发的场景：前端和后端开发人员开发同一个项目。

#### 3.2.1、不好的设计

```swift
class FrondEndDeveloper {
    func writeJavaScriptCode() {
        // 编写 JavaScript
    }
}

class BackEndDeveloper {
    func writeJavaCode() {
        // 编写 Java
    }
}

// 表面上看，这样设计并没有什么问题，这两个开发者分别对外提供了自己开发的方法。
//
// 接下来就是立项开始编码

class Project {
    /// 开发小组
    var developers: [AnyObject]
    
    /// 整个项目组开始编码
    func startDeveloping() {
        for developer in developers {
            if let frondEndDeveloper = developer as? FrondEndDeveloper {
                frondEndDeveloper.writeJavaScriptCode()
                continue
            }
            if let backEndDeveloper = developer as? BackEndDeveloper {
                backEndDeveloper.writeJavaCode()
                continue
            }
        }
    }
}
```

思考一下，这样的设计有什么问题？

1. 假如后台的开发语言改成了 Go，那么上述代码需要改动两个地方：`BackEndDeveloper` 和 `Project`
2. 假如后期项目要做移动端 App，创建完 `iOSDeveloper` 和 `AndroidDeveloper` 后，仍然需要改 `Project` 的 `startDeveloping` 方法

很显然，在这两种假设的场景下，高层模块（`Project`）都依赖了低层模块（`BackEndDeveloper` 等）的改动，因此上述设计不符合依赖倒置原则。

#### 3.2.2、较好的设计

那么该如何设计才可以符合依赖倒置原则呢？

答案是将开发者写代码的方法抽象出来，让 `Project` 类不再依赖所有低层的开发者类的具体实现，而是依赖抽象。而且从下至上，所有底层的开发者类也都依赖这个抽象，通过实现这个抽象来做自己的任务。

```swift
protocol DeveloperProtocol {
    func writeCode()
}

class FrondEndDeveloper: DeveloperProtocol {
    func writeCode() {
        // 编写 JavaScript
    }
}

class BackEndDeveloper: DeveloperProtocol {
    func writeCode() {
        // 编写 Java
    }
}

class Project {
    /// 开发小组
    var developers: [DeveloperProtocol]
    
    /// 整个项目组开始编码
    func startDeveloping() {
        developers.forEach { $0.writeCode() }
    }
}
```

这样一来，`BackEndDeveloper` 要更换 Golang，只修改自己的实现即可；新增的 `iOSDeveloper` 和 `AndroidDeveloper` 遵循 `DeveloperProtocol`，加入 `Project` 即可，不再需要更改 `startDeveloping` 方法。

### 3.3、UML 类图对比

![](https://github.com/liufannnn/liufannnn/blob/main/BlogImages/依赖倒置原则UML类图.png?raw=true)

### 3.4、回读定义

    1. Depend upon Abstractions. Do not depend upon concretions.
    2. Abstractions should not depend upon details. Details should depend upon abstractions.
    3. High-level modules should not depend on low-level modules. Both should depend on abstractions.
    
    1、依赖抽象，而不是依赖实现；
    2、抽象不应该依赖细节，细节应该依赖抽象；
    3、高层模块不能依赖低层模块，二者都应该依赖抽象。

以上文 `Project` 类来说：
1. `developers` 属性依赖抽象的 `DeveloperProtocol` 即可（要求会写代码）；
2. 抽象的 `DeveloperProtocol` 并不指定具体写哪种代码；
3. 高层模块 `Project` 不依赖低层模块 `FrondEndDeveloper` 和 `BackEndDeveloper`，二者都依赖抽象的 `DeveloperProtocol`。

今后在处理高低层模块（类）交互的情景时，尽量将二者的依赖通过抽象的方式解除掉，实现方式可以是通过<a name="myfootnote1">接口</a>也可以是抽象类的方式。

关于高层模块与低层模块的划分可以按照决策能力的高低进行划分。业务层自然就处于上层模块，逻辑层和数据层自然就归类为低层。

## 4、接口分离原则（Interface Segregation Principle）

### 4.1、定义

    Many client specific interfaces are better than one general purpose interface.
    
    多个特定的客户端接口要好于一个通用性的总接口。

### 4.2、需求实践

需求：现在的餐厅除了提供传统的店内服务，多数也都支持网上下单，网上支付功能。写一些<a name="myfootnote1">接口</a>方法来涵盖餐厅的所有的下单及支付功能。

> 这里不展开讨论电话下单是否可以店内支付，默认电话下单为 online 支付

#### 4.2.1、不好的设计

```swift
protocol RestaurantProtocol {
    func placeOnlineOrder()         // 下订单：online
    func placeTelephoneOrder()      // 下订单：通过电话
    func placeWalkInCustomerOrder() // 下订单：在店里

    func payOnline()                // 支付订单：online
    func payInPerson()              // 支付订单：在店里
}

// ⬇️⬇️⬇️ 对应的，我们有三种下单方式的顾客 ⬇️⬇️⬇️

/// online下单，online支付
class OnlineClient: RestaurantProtocol {
    func placeOnlineOrder() {
        // 下订单：online
    }
    func placeTelephoneOrder() {
        // 没实现的必要
    }
    func placeWalkInCustomerOrder() {
        // 没实现的必要
    }

    func payOnline() {
        // 支付订单：online
    }
    func payInPerson() {
        // 没实现的必要
    }
}

/// 电话下单，online支付
class TelephoneClient: RestaurantProtocol {
    func placeOnlineOrder() {
        // 没实现的必要
    }
    func placeTelephoneOrder() {
        // 下订单：通过电话
    }
    func placeWalkInCustomerOrder() {
        // 没实现的必要
    }

    func payOnline() {
        // 支付订单：online
    }
    func payInPerson() {
        // 没实现的必要
    }
}

/// 在店里下单并支付的顾客
class WalkinClient: RestaurantProtocol {
    func placeOnlineOrder() {
        // 没实现的必要
    }
    func placeTelephoneOrder() {
        // 没实现的必要
    }
    func placeWalkInCustomerOrder() {
        // 支付订单：在店里
    }

    func payOnline() {
        // 没实现的必要
    }
    func payInPerson() {
        // 支付订单：在店里
    }
}
```

我们发现，并不是所有顾客都必须要实现 `RestaurantProtocol` 里面的所有方法。由于<a name="myfootnote1">接口</a>方法的设计造成了冗余，因此该设计不符合接口隔离原则。

并且，以后随着餐厅业务扩展，支持预定、团餐月结等业务，所有遵循 `RestaurantProtocol` <a name="myfootnote1">接口</a>的类都需要做相应修改。

> 注意，iOS 开发中的协议可以通过 Objective-C 的 `@optional` 关键字设置为可选实现的方法。
>
> 该特性与接口分离原则并不冲突：只要属于同一类<a name="myfootnote1">接口</a>的方法，都可以放入同一<a name="myfootnote1">接口</a>中。

#### 4.2.2、较好的设计

```swift
protocol RestaurantPlaceOrderProtocol {
    func placeOrder() // 下单
}

protocol RestaurantPaymentProtocol {
    func payOrder()   // 支付
}

// 现在有了下单接口和支付接口，我们就可以让不同的客户来以自己的方式实现下单和支付操作了
//
// 首先创建一个所有客户的父类，来遵循这个两个接口

class Client: RestaurantPlaceOrderProtocol, RestaurantPaymentProtocol {
    func placeOrder() {
        // 下单
    }

    func payOrder() {
        // 支付
    }
}

// 接着让online下单，电话下单，店内下单的顾客继承这个父类，分别实现这两个接口的方法

class OnlineClient: Client {
    func placeOrder() {
        // 在线下单
    }

    func payOrder() {
        // 在线支付
    }
}

class TelephoneClient: Client {
    func placeOrder() {
        // 电话下单
    }

    func payOrder() {
        // 在线支付
    }
}

class WalkinClient: Client {
    func placeOrder() {
        // 店内下单
    }

    func payOrder() {
        // 店内支付
    }
}
```

这里把下单和支付作为不同职责的<a name="myfootnote1">接口</a>拆开，使得<a name="myfootnote1">接口</a>的责任更加清晰。因此不同的客户端可以根据自己的需求遵循所需要的接<a name="myfootnote1">接口</a>来以自己的方式实现。

以后餐厅扩展预定、团餐月结等业务时，只需要创建一个新的对应<a name="myfootnote1">接口</a>，让需要的客户子类单独遵循即可。

### 4.3、UML 类图对比

![](https://github.com/liufannnn/liufannnn/blob/main/BlogImages/接口分离原则UML类图.png?raw=true)

### 4.4、回读定义

    Many client specific interfaces are better than one general purpose interface.
    
    多个特定的客户端接口要好于一个通用性的总接口。

不要建立庞大臃肿的接口，应尽量细化接口，接口中的方法应该尽量少。

做 iOS 开发的朋友对 `UITableView` 的 `UITableViewDelegate` 和 `UITableViewDataSource` 这两个协议应该会非常熟悉。这两个协议里的方法都是与 `UITableView` 相关的，但 iOS SDK 的设计者却把这些方法放在不同的两个协议中。原因就是这两个协议所包含的方法所处理的任务是不同的两种：
1. `UITableViewDataSource`含有的方法是 `UITableView` 的代理传给 `UITableView` 一些必要数据供 `UITableView` 展示出来，即数据的传递，方向是从 `UITableView` 的代理到 `UITableView`；
2. `UITableViewDelegate` 含有的方法是 `UITableView` 的实例告知其代理一些如点击事件的方法，即事件的传递，方向是从 `UITableView` 的实例到其代理。

## 5、迪米特法则（Law of Demeter）

### 5.1、定义

    You only ask for objects which you directly need.
    
    一个对象应该对尽可能少的对象有接触，也就是只接触那些真正需要接触的对象。

### 5.2、需求实践

需求：设计一个汽车类，包含汽车的品牌名称，引擎等成员变量。提供一个方法返回引擎的品牌名称。

#### 5.2.1、不好的设计

```swift
class GasEngine {
    var brand: String // 引擎品牌
}

class Car {
    var brand: String                     // 汽车品牌
    private var gasEngine: GasEngine // 引擎

    init(brand: String, gasEngine: GasEngine) {
        self.brand = brand
        self.gasEngine = gasEngine
    }

    /// 当前正在使用的引擎
    func usingEngine() -> GasEngine {
        return self.gasEngine
    }
}

// 这样一来，客户端就可以拿到引擎的品牌名称了

/// 汽车之家客户端
class CarHomeClient {
    func findCarEngineBrand(car: Car) -> String {
        return car.usingEngine().brand
    }
}
```

上面的设计完成了需求，但是却违反了迪米特法则。原因是在客户端的 `findCarEngineBrand` 方法中引入了和入参（`Car`）返回值（`String`）无关的 `GasEngine` 对象。增加了客户端与 `GasEngine` 的耦合。而这个耦合显然是不必要更是可以避免的。

#### 5.2.2、较好的设计

```swift
class GasEngine {
    var brand: String // 引擎品牌
}

class Car {
    var brand: String                // 汽车品牌
    private var gasEngine: GasEngine // 引擎

    init(brand: String, gasEngine: GasEngine) {
        self.brand = brand
        self.gasEngine = gasEngine
    }

    /// 当前正在使用的引擎品牌
    func usingEngineBrand() -> GasEngine {
        return self.gasEngine.brand
    }
}

/// 汽车之家客户端
class CarHomeClient {
    func findCarEngineBrand(car: Car) -> String {
        return car.usingEngineBrand()
    }
}
```

与之前的设计不同，在 `CarHomeClient` 里面，没有引入 `GasEngine` 类，而是直接通过 `Car` 实例获取到了需要的数据。

这样设计的好处是，如果这辆车的引擎换成了电动引擎(原来的 `GasEngine` 类换成了 `ElectricEngine` 类)，客户端代码可以不做任何修改！因为它没有引入任何引擎类，而是直接获取了引擎的品牌名称。

### 5.3、UML 类图对比

![](https://github.com/liufannnn/liufannnn/blob/main/BlogImages/迪米特法则UML类图.png?raw=true)

### 5.4、回读定义

    Many client specific interfaces are better than one general purpose interface.
    
    多个特定的客户端接口要好于一个通用性的总接口。

迪米特法则也叫做最少知道原则（Least Know Principle）， 一个类应该只和它的成员变量，方法的输入，返回参数中的类作交流，而不应该引入其他的类（间接交流）。

今后在做对象与对象之间交互的设计时，应该极力避免引出中间对象的情况（需要导入其他对象的类）：需要什么对象直接返回即可，降低类之间的耦合度。

## 6、里氏替换原则（Liskov Substitution Principle）

### 6.1、定义

    In a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) without altering any of the desirable properties of the program (correctness, task performed, etc.)
    
    所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。

### 6.2、需求实践

燕子的飞行速度大概是每小时 120 千米，新西兰的几维鸟由于翅膀退化无法飞行，计算这两种鸟飞行 300 千米要花费的时间。

#### 6.2.1、不好的设计

```swift
class Bird {
    var flySpeed: Double

    init(flySpeed: Double) {
        self.flySpeed = flySpeed
    }

    func getFlyTime(distance: Double) -> Double {
        return distance / flySpeed
    }
}

class Swallow: Bird {
}

class BrownKiwi: Bird {
    override var flySpeed: Double {
        didSet {
            flySpeed = 0
        }
    }
}

let swallow = Swallow(flySpeed: 120)
let brownKiwi = BrownKiwi(flySpeed: 120)
let swallowTime = swallow.getFlyTime(distance: 300)     // 燕子将飞行2.5小时
let brownKiwiTime = brownKiwi.getFlyTime(distance: 300) // 几维鸟将飞行无限长时间
```

这个设计存在的问题是：
1. 几维鸟类重写了 `Bird` 类的 `flySpeed` 方法，这违背了里氏替换原则；
2. 燕子和几维鸟都是鸟类，但是父类抽取的共性有问题，几维鸟的飞行不是正常鸟类的功能，需要特殊处理，应该抽取更加共性的的功能。

#### 6.2.2、较好的设计

```swift
class Animal {
    var runSpeed: Double

    init(runSpeed: Double) {
        self.runSpeed = runSpeed
    }

    func getRunTime(distance: Double) -> Double {
        return distance / runSpeed
    }
}

class Bird: Animal {
    var flySpeed: Double

    init(flySpeed: Double, runSpeed: Double) {
        self.flySpeed = flySpeed
        super.init(runSpeed: runSpeed)
    }

    func getFlyTime(distance: Double) -> Double {
        return distance / flySpeed
    }
}

class Swallow: Bird {
}

class BrownKiwi: Animal {
}

let swallow = Swallow(flySpeed: 120)
let brownKiwi = BrownKiwi(flySpeed: 120)
let swallowTime = swallow.getFlyTime(distance: 300)     // 燕子将飞行2.5小时
let brownKiwiTime = brownKiwi.getRunTime(distance: 300) // 几维鸟将奔跑1.66666667小时
```

这样设计虽然增加了一个动物类，但是我的子类仅仅是继承父类，不去重写父类的方法。这样在代码层面，父类若是替换成子类，那么程序仍然能够正常运行。

### 6.3、UML 类图对比

![](https://github.com/liufannnn/liufannnn/blob/main/BlogImages/里氏替换原则UML类图.png?raw=true)

### 6.4、回读定义

    In a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) without altering any of the desirable properties of the program (correctness, task performed, etc.)
    
    所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。

里氏替换原则是对继承关系的一种检验：检验是否真正符合继承关系，以避免继承的滥用。因此，在使用继承之前，需要反复思考和确认该继承关系是否正确，或者当前的继承体系是否还可以支持后续的需求变更，如果无法支持，则需要及时重构，采用更好的方式来设计程序。

脚注：
1. <a name="myfootnote1">接口</a>: iOS 开发中的协议